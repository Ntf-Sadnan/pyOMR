<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyOMR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onCvReady();"></script>
    <style>
        /* A simple pulse animation */
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }

        /* Webkit scrollbar styling */
        pre::-webkit-scrollbar { width: 8px; height: 8px; }
        pre::-webkit-scrollbar-track { background: #1a202c; }
        pre::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; border: 2px solid #1a202c; }

        /* Camera Modal Styles */
        #cameraModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); display: none;
            justify-content: center; align-items: center; z-index: 1000;
        }

        #cameraContainer {
            position: relative; width: 90vw; max-width: 500px;
            aspect-ratio: 601 / 775; background: #000;
            border-radius: 8px; overflow: hidden;
        }
        
        #cameraFeed {
            position: absolute; top: 50%; left: 50%;
            width: 100%; height: 100%;
            object-fit: cover; /* This causes the capture crop issue we will solve */
            transform: translate(-50%, -50%);
        }

        /* Styles for the PERMANENT guide boxes */
        .guide-box {
            position: absolute; width: 60px; height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-radius: 4px;
            transition: border-color 0.2s ease-in-out;
            z-index: 5;
        }
        #guide-box-tl { top: 20px; left: 20px; }
        #guide-box-tr { top: 20px; right: 20px; }
        #guide-box-bl { bottom: 20px; left: 20px; }
        #guide-box-br { bottom: 20px; right: 20px; }

        /* The 'aligned' state when a marker is inside */
        .guide-box.is-aligned {
            border-color: #4ade80; /* A bright green */
        }
        
        #captureButton, #closeCameraButton {
            position: absolute; z-index: 10; cursor: pointer;
            background-color: rgba(0, 0, 0, 0.5); color: #fff;
            border: none; border-radius: 9999px;
        }
        #captureButton {
            bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 12px 24px; font-weight: bold;
            background-color: #fff; color: #1a202c;
        }
        #closeCameraButton { top: 20px; right: 20px; padding: 8px; }
        .hidden { display: none !important; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-5xl">
        <header class="text-center mb-10">
            <h1 class="text-4xl sm:text-5xl font-bold text-white">PyOMR</h1>
            <p class="text-gray-400 mt-3 text-lg">Align the OMR sheet's corners with the guide boxes.</p>
        </header>

        <div class="max-w-xl mx-auto mb-10">
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button id="useCameraButton" class="w-full bg-white text-gray-900 font-bold py-3 px-4 rounded-lg hover:bg-gray-200 transition-colors duration-300 flex items-center justify-center space-x-2">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    <span>Use Camera</span>
                </button>
                <button id="selectGalleryButton" class="w-full bg-gray-700 text-white font-bold py-3 px-4 rounded-lg hover:bg-gray-600 border border-gray-600 transition-colors duration-300 flex items-center justify-center space-x-2">
                     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    <span>Choose from Gallery</span>
                </button>
            </div>
        </div>
        <input type="file" id="imageInput" accept="image/*" class="hidden">

        <div id="cameraModal">
            <div id="cameraContainer">
                <video id="cameraFeed" autoplay playsinline></video>
                <div id="guide-box-tl" class="guide-box"></div>
                <div id="guide-box-tr" class="guide-box"></div>
                <div id="guide-box-bl" class="guide-box"></div>
                <div id="guide-box-br" class="guide-box"></div>
                <canvas id="processingCanvas" class="hidden"></canvas>
                <button id="captureButton">Capture</button>
                <button id="closeCameraButton">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
            </div>
        </div>

        <div id="cvStatus" class="text-center my-2 font-semibold text-yellow-400"></div>
        <div id="status" class="text-center my-5 font-semibold text-gray-400 min-h-[24px]"></div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div>
                <h2 class="text-xl font-bold text-white mb-4">Input Image</h2>
                <div class="bg-gray-800 rounded-lg p-4 min-h-[300px] flex items-center justify-center border border-gray-700">
                    <img id="imagePreview" src="" alt="Preview of the selected image" class="max-w-full h-auto rounded-lg hidden">
                    <span id="imagePreviewPlaceholder" class="text-gray-500">Select an image to begin</span>
                </div>
            </div>
            <div>
                <h2 class="text-xl font-bold text-white mb-4">Processed Image</h2>
                <div id="resultsContainer" class="bg-gray-800 rounded-lg p-4 min-h-[300px] flex items-center justify-center border border-gray-700">
                    <img id="resultsImage" src="" alt="Processed image from the API" class="max-w-full h-auto rounded-lg hidden">
                    <div id="resultsLoader" class="hidden text-center text-gray-500">
                        <div class="w-8 h-8 border-4 border-blue-400 border-t-transparent rounded-full animate-spin mx-auto"></div>
                        <p class="mt-3">Processing your image...</p>
                    </div>
                    <span id="resultsImagePlaceholder" class="text-gray-500">Results will appear here</span>
                </div>
            </div>
        </div>

        <div class="mt-10">
            <h2 class="text-xl font-bold text-white mb-4">Detected Answers (JSON)</h2>
            <div class="bg-gray-800 rounded-lg border border-gray-700">
                <pre id="resultsJson" class="p-4 rounded-lg text-sm text-gray-300 overflow-x-auto min-h-[150px]"></pre>
            </div>
        </div>
    </div>

    <script>
        const imageInput = document.getElementById('imageInput');
        const useCameraButton = document.getElementById('useCameraButton');
        const selectGalleryButton = document.getElementById('selectGalleryButton');
        const statusDiv = document.getElementById('status');
        const cvStatusDiv = document.getElementById('cvStatus');
        const imagePreview = document.getElementById('imagePreview');
        const imagePreviewPlaceholder = document.getElementById('imagePreviewPlaceholder');
        const resultsImage = document.getElementById('resultsImage');
        const resultsImagePlaceholder = document.getElementById('resultsImagePlaceholder');
        const resultsLoader = document.getElementById('resultsLoader');
        const resultsJson = document.getElementById('resultsJson');
        const cameraModal = document.getElementById('cameraModal');
        const cameraContainer = document.getElementById('cameraContainer');
        const cameraFeed = document.getElementById('cameraFeed');
        const captureButton = document.getElementById('captureButton');
        const closeCameraButton = document.getElementById('closeCameraButton');
        const guideBoxes = { tl: document.getElementById('guide-box-tl'), tr: document.getElementById('guide-box-tr'), bl: document.getElementById('guide-box-bl'), br: document.getElementById('guide-box-br') };
        const processingCanvas = document.getElementById('processingCanvas');

        let fileAsBase64 = null, stream = null, isCvReady = false, isStreaming = false, animationFrameId = null;

        function onCvReady() {
            if (!cv) { cvStatusDiv.textContent = "Error: Could not load real-time analysis engine."; return; }
            isCvReady = true;
            cvStatusDiv.textContent = "Real-time analysis engine loaded.";
            setTimeout(() => { cvStatusDiv.textContent = ""; }, 3000);
        }
        if (typeof cv === 'undefined') { cvStatusDiv.textContent = 'Loading real-time analysis engine...'; } else { onCvReady(); }

        useCameraButton.addEventListener('click', () => startCamera());
        selectGalleryButton.addEventListener('click', () => imageInput.click());
        closeCameraButton.addEventListener('click', () => stopCamera());

        captureButton.addEventListener('click', () => {
            const dataUrl = captureVisibleFrame();
            if (dataUrl) {
                stopCamera();
                handleImageData(dataUrl);
            }
        });

        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => handleImageData(e.target.result);
            reader.readAsDataURL(file);
        });
        
        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { statusDiv.textContent = 'Your browser does not support camera access.'; return; }
            if (!isCvReady) { statusDiv.textContent = 'Please wait, analysis engine is loading.'; return; }
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                cameraFeed.srcObject = stream;
                cameraModal.style.display = 'flex';
                cameraFeed.onloadedmetadata = () => {
                    processingCanvas.width = cameraFeed.videoWidth;
                    processingCanvas.height = cameraFeed.videoHeight;
                    isStreaming = true;
                    requestAnimationFrame(processVideo);
                };
            } catch (error) { console.error('Error accessing camera.', error); statusDiv.textContent = 'Could not access camera. Check permissions.'; }
        }

        function stopCamera() {
            isStreaming = false;
            if (stream) { stream.getTracks().forEach(track => track.stop()); }
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            Object.values(guideBoxes).forEach(box => box.classList.remove('is-aligned'));
            cameraModal.style.display = 'none';
        }
        
        function processVideo() {
            if (!isStreaming || !isCvReady) return;

            const videoWidth = processingCanvas.width;
            const videoHeight = processingCanvas.height;
            processingCanvas.getContext('2d').drawImage(cameraFeed, 0, 0, videoWidth, videoHeight);

            let src = cv.imread(processingCanvas);
            let gray = new cv.Mat(); let blurred = new cv.Mat(); let binary = new cv.Mat();
            let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
            let alignmentStatus = { tl: false, tr: false, bl: false, br: false };

            try {
                // **IMPROVED DETECTION PIPELINE**
                // 1. Convert to Grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                // 2. Blur to remove noise
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                // 3. Use Adaptive Thresholding - MUCH more robust than a fixed threshold
                cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 4);
                
                cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                for (let i = 0; i < contours.size(); ++i) {
                    const cnt = contours.get(i);
                    const area = cv.contourArea(cnt);
                    
                    if (area > 500 && area < 50000) { 
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.04 * peri, true);

                        if (approx.rows === 4) {
                            const M = cv.moments(cnt, false);
                            const cx = M.m10 / M.m00; const cy = M.m01 / M.m00;
                            if (cx < videoWidth * 0.25 && cy < videoHeight * 0.25) alignmentStatus.tl = true;
                            else if (cx > videoWidth * 0.75 && cy < videoHeight * 0.25) alignmentStatus.tr = true;
                            else if (cx < videoWidth * 0.25 && cy > videoHeight * 0.75) alignmentStatus.bl = true;
                            else if (cx > videoWidth * 0.75 && cy > videoHeight * 0.75) alignmentStatus.br = true;
                        }
                        approx.delete();
                    }
                }
                updateGuideBoxUI(alignmentStatus);
            } catch(e) { console.error("OpenCV processing error:", e); } 
            finally {
                src.delete(); gray.delete(); blurred.delete(); binary.delete(); contours.delete(); hierarchy.delete();
            }
            animationFrameId = requestAnimationFrame(processVideo);
        }

        function updateGuideBoxUI(status) {
            guideBoxes.tl.classList.toggle('is-aligned', status.tl);
            guideBoxes.tr.classList.toggle('is-aligned', status.tr);
            guideBoxes.bl.classList.toggle('is-aligned', status.bl);
            guideBoxes.br.classList.toggle('is-aligned', status.br);
        }

        /**
         * Captures only the visible portion of the video feed, accounting for 'object-fit: cover'.
         * This ensures the captured image matches what the user sees.
         */
        function captureVisibleFrame() {
            const video = cameraFeed;
            const container = cameraContainer;
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const videoRatio = videoWidth / videoHeight;
            const containerRatio = containerWidth / containerHeight;

            let sx = 0, sy = 0, sWidth = videoWidth, sHeight = videoHeight;

            // Figure out the cropping
            if (videoRatio > containerRatio) { // Video is wider than container, so we crop the sides
                sWidth = videoHeight * containerRatio;
                sx = (videoWidth - sWidth) / 2;
            } else { // Video is taller than container, so we crop top and bottom
                sHeight = videoWidth / containerRatio;
                sy = (videoHeight - sHeight) / 2;
            }
            
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = sWidth;
            captureCanvas.height = sHeight;
            const ctx = captureCanvas.getContext('2d');

            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
            return captureCanvas.toDataURL('image/jpeg');
        }

        const handleImageData = (dataUrl) => {
            imagePreview.src = dataUrl;
            imagePreview.classList.remove('hidden');
            imagePreviewPlaceholder.classList.add('hidden');
            fileAsBase64 = dataUrl.split(',')[1];
            scanImage();
        };

        const scanImage = async () => {
            if (!fileAsBase64) { statusDiv.textContent = "No file data is available."; return; }
            statusDiv.textContent = "Processing... Please wait.";
            resultsImage.classList.add('hidden');
            resultsImagePlaceholder.classList.add('hidden');
            resultsLoader.classList.remove('hidden');
            resultsJson.textContent = "";
            useCameraButton.disabled = true; selectGalleryButton.disabled = true;
            try {
                const response = await fetch('https://pyomr.onrender.com/scan', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ base64_data: fileAsBase64 }) });
                if (!response.ok) { const errorData = await response.json(); throw new Error(`API Error: ${response.status} - ${errorData.error || 'Unknown error'}`); }
                const data = await response.json();
                resultsImage.src = `data:image/jpeg;base64,${data['scanned_results.jpg']}`;
                resultsImage.classList.remove('hidden');
                resultsJson.textContent = JSON.stringify(data['omr_base_data.json'], null, 2);
                statusDiv.textContent = "Scan complete!";
            } catch (error) {
                console.error('Failed to scan:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                resultsJson.textContent = `An error occurred. See console for details.`;
                resultsImagePlaceholder.classList.remove('hidden');
            } finally {
                resultsLoader.classList.add('hidden');
                useCameraButton.disabled = false; selectGalleryButton.disabled = false;
            }
        };
    </script>
</body>
</html>
